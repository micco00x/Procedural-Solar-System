<html>
	<head>
		<title>ProceduralSS</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
		
		<script src="third_party/three/three.min.js"></script>
		<script src="third_party/three/controls/FlyControls.js"></script>
		
		<script src="third_party/seedrandom.min.js"></script>
		<script src="third_party/simplex-noise.js"></script>
		<script src="third_party/ImprovedNoise.js"></script>
		
		<script src="third_party/stats/stats.min.js"></script>
		<script src="third_party/gui/dat.gui.min.js"></script>
		
		<script type="x-shader/x-vertex" id="basicVertexShader">
			varying vec3 pos;
			varying vec3 posCameraCoord; // need this becasue light is in camera coords.
			varying vec3 n;
			
			varying vec2 vUV;
			
			void main()
			{
				pos = (modelMatrix * vec4(position, 1.0)).xyz;
				posCameraCoord = (modelViewMatrix * vec4(position, 1.0)).xyz;
				
				n = normalMatrix * normal;
				
				vUV = uv;
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script type="x-shader/x-fragment" id="basicFragmentShader">
			struct PointLight {
				vec3 color;
				vec3 position;
				float distance;
			};
		
			uniform float emissiveLightIntensity;
			uniform PointLight pointLights[NUM_POINT_LIGHTS];
			uniform float pointLightIntensity[NUM_POINT_LIGHTS];
		
			// used to correctly compute noiseHeight when the planet is moved:
			uniform vec3 planetPosition;
			uniform float radius;
			
			uniform sampler2D texture[8];   // textures characterizing the planet
			uniform float textureHeight[8]; // heights from where the texture changes
		
			varying vec3 pos;
			varying vec3 posCameraCoord;
			varying vec3 n;
			
			varying vec2 vUV;
			
			void main()
			{
				// Iterate through lights:
				vec3 totLight = vec3(0.0, 0.0, 0.0);
				for (int i = 0; i < NUM_POINT_LIGHTS; ++i) {
					vec3 l = posCameraCoord - pointLights[i].position;
					if (pointLights[i].distance == 0.0 || length(l) < pointLights[i].distance) {
						vec3 lightDirection = normalize(l);
						totLight += clamp(dot(-lightDirection, n), 0.0, 1.0) * pointLights[i].color * pointLightIntensity[i];
					}
				}
				
				// Compute noise height to determine the texture to be used:
				float noiseHeight = length(pos - planetPosition) - radius;
				
				// Each height has its own texture:
				if (noiseHeight < textureHeight[0]) {
					gl_FragColor = texture2D(texture[0], vUV);
				} else if (noiseHeight < textureHeight[1]) {
					gl_FragColor = texture2D(texture[1], vUV);
				} else if (noiseHeight < textureHeight[2]) {
					gl_FragColor = texture2D(texture[2], vUV);
				} else if (noiseHeight < textureHeight[3]) {
					gl_FragColor = texture2D(texture[3], vUV);
				} else if (noiseHeight < textureHeight[4]) {
					gl_FragColor = texture2D(texture[4], vUV);
				} else if (noiseHeight < textureHeight[5]) {
					gl_FragColor = texture2D(texture[5], vUV);
				} else if (noiseHeight < textureHeight[6]) {
					gl_FragColor = texture2D(texture[6], vUV);
				} else {
					gl_FragColor = texture2D(texture[7], vUV);
				}
				
				gl_FragColor = gl_FragColor * vec4(totLight, 1.0) + gl_FragColor * emissiveLightIntensity * vec4(1.0, 1.0, 1.0, 1.0);
				
				if (gl_FragColor.r > 1.0) gl_FragColor.r = 1.0;
				if (gl_FragColor.g > 1.0) gl_FragColor.g = 1.0;
				if (gl_FragColor.b > 1.0) gl_FragColor.b = 1.0;
			}
		</script>
		
		<script type="x-shader/x-vertex" id="particlesVertexShader">
			
			//attribute vec3 aPosition;
			//attribute vec3 aDirection;
			//attribute vec3 aRotation;
			//attribute vec3 aColor;
			//attribute float aSpeed;
			
			//uniform float uStartDistance;
			//uniform float uEndDistance;
			//uniform vec3 uCenter;
			//uniform float uTime;
			
			//varying vec3 vColor;
			
			void main() {
				
				//vec3 position = aPosition;
				position[0] = 10000.0 * position[0];
				position[1] = 10000.0 * position[1];
				position[2] = 10000.0 * position[2];
				
				
				// covered distance
				//float movement = mod((aSpeed * uTime), (uEndDistance - uStartDistance));
				//movement = movement +  uStartDistance;
				//
				// rotate particles
				
				// scale particles
			
				// translate particles at the correct position (between start_position and end position)
				// translate WRT system center and particle local position
				//vec3 local_translation = movement * aDirection;
				//vec3 translation = uCenter + local_translation;
				//position = position + translation;
				
				//vColor = aColor;
				gl_Position = position;
			}
		</script>
		<script type="x-shader/x-fragment" id="particlesFragmentShader">
			//varying vec3 vColor;
			
			void main() 
			{
				gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
			}
		</script>
		
		<script src="src/Chunk.js"></script>
		<script src="src/NoiseHeightGenerator.js"></script>
		<script src="src/Collisions.js"></script>
		<script src="src/TextureGenerator.js"></script>
		<script src="src/GraphicalTag.js"></script>
		<script src="src/Planet.js"></script>
		<script src="src/ParticlesEffects.js"></script>
		<script src="src/Main.js"></script>
	</head>
	<body>
	</body>
</html>
