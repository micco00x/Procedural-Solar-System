<html>
	<head>
		<title>ProceduralSS</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
		
		<script src="third_party/three/three.min.js"></script>
		<script src="third_party/three/controls/FlyControls.js"></script>
		
		<script src="third_party/seedrandom.min.js"></script>
		<script src="third_party/simplex-noise.js"></script>
		<script src="third_party/ImprovedNoise.js"></script>
		
		<script src="third_party/stats/stats.min.js"></script>
		<script src="third_party/gui/dat.gui.min.js"></script>
		
		<script type="x-shader/x-vertex" id="basicVertexShader">
			varying vec3 pos;
			varying vec3 posCameraCoord; // need this becasue light is in camera coords.
			varying vec3 n;
			
			varying vec2 vUV;
			
			void main()
			{
				pos = (modelMatrix * vec4(position, 1.0)).xyz;
				posCameraCoord = (modelViewMatrix * vec4(position, 1.0)).xyz;
				
				n = normalMatrix * normal;
				
				vUV = uv;
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script type="x-shader/x-fragment" id="basicFragmentShader">
			struct PointLight {
				vec3 color;
				vec3 position;
				float distance;
			};
		
			uniform float emissiveLightIntensity;
			uniform PointLight pointLights[NUM_POINT_LIGHTS];
			uniform float pointLightIntensity[NUM_POINT_LIGHTS];
		
			// used to correctly compute noiseHeight when the planet is moved:
			uniform vec3 planetPosition;
			uniform float radius;
			
			uniform sampler2D texture[8];   // textures characterizing the planet
			uniform float textureHeight[8]; // heights from where the texture changes
		
			varying vec3 pos;
			varying vec3 posCameraCoord;
			varying vec3 n;
			
			varying vec2 vUV;
			
			void main()
			{
				// Iterate through lights:
				vec3 totLight = vec3(0.0, 0.0, 0.0);
				for (int i = 0; i < NUM_POINT_LIGHTS; ++i) {
					vec3 l = posCameraCoord - pointLights[i].position;
					if (pointLights[i].distance == 0.0 || length(l) < pointLights[i].distance) {
						vec3 lightDirection = normalize(l);
						totLight += clamp(dot(-lightDirection, n), 0.0, 1.0) * pointLights[i].color * pointLightIntensity[i];
					}
				}
				
				// Compute noise height to determine the texture to be used:
				float noiseHeight = length(pos - planetPosition) - radius;
				
				// Each height has its own texture:
				if (noiseHeight < textureHeight[0]) {
					gl_FragColor = texture2D(texture[0], vUV);
				} else if (noiseHeight < textureHeight[1]) {
					gl_FragColor = texture2D(texture[1], vUV);
				} else if (noiseHeight < textureHeight[2]) {
					gl_FragColor = texture2D(texture[2], vUV);
				} else if (noiseHeight < textureHeight[3]) {
					gl_FragColor = texture2D(texture[3], vUV);
				} else if (noiseHeight < textureHeight[4]) {
					gl_FragColor = texture2D(texture[4], vUV);
				} else if (noiseHeight < textureHeight[5]) {
					gl_FragColor = texture2D(texture[5], vUV);
				} else if (noiseHeight < textureHeight[6]) {
					gl_FragColor = texture2D(texture[6], vUV);
				} else {
					gl_FragColor = texture2D(texture[7], vUV);
				}
				
				gl_FragColor = gl_FragColor * vec4(totLight, 1.0) + gl_FragColor * emissiveLightIntensity * vec4(1.0, 1.0, 1.0, 1.0);
				
				if (gl_FragColor.r > 1.0) gl_FragColor.r = 1.0;
				if (gl_FragColor.g > 1.0) gl_FragColor.g = 1.0;
				if (gl_FragColor.b > 1.0) gl_FragColor.b = 1.0;
			}
		</script>
		
		<script src="src/Chunk.js"></script>
		<script src="src/NoiseHeightGenerator.js"></script>
		<script src="src/Planet.js"></script>
		<script src="src/SimpleSphericalOcean.js"></script>
		<script src="src/Main.js"></script>
	</head>
	<body>
	</body>
</html>
