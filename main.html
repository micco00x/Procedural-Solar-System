<html>
	<head>
		<title>ProceduralSS</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
		
		<script src="third_party/three/three.min.js"></script>
		<script src="third_party/three/controls/FlyControls.js"></script>
		
		<script src="third_party/seedrandom.min.js"></script>
		<script src="third_party/simplex-noise.js"></script>
		<script src="third_party/ImprovedNoise.js"></script>
		
		<script src="third_party/stats/stats.min.js"></script>
		
		<script type="x-shader/x-vertex" id="basicVertexShader">
			varying vec3 pos;
			varying vec3 posCameraCoord; // need this becasue light is in camera coords.
			varying vec3 n;
			
			varying vec2 vUV;
			
			void main()
			{
				pos = (modelMatrix * vec4(position, 1.0)).xyz;
				posCameraCoord = (modelViewMatrix * vec4(position, 1.0)).xyz;
				
				n = normalMatrix * normal;
				
				vUV = uv;
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script type="x-shader/x-fragment" id="basicFragmentShader">
			struct PointLight {
				vec3 color;
				vec3 position;
				//float distance;
			};
		
			uniform PointLight pointLights[NUM_POINT_LIGHTS];
			float lightIntensity = 1.0;
		
			uniform float radius;
			
			uniform sampler2D texture0;
			uniform sampler2D texture1;
			uniform sampler2D texture2;
			uniform sampler2D texture3;
			uniform sampler2D texture4;
			uniform sampler2D texture5;
			uniform sampler2D texture6;
			uniform sampler2D texture7;
		
			varying vec3 pos;
			varying vec3 posCameraCoord;
			varying vec3 n;
			
			varying vec2 vUV;
			
			void main()
			{
				// TODO: add cycle for multiple lights
				vec3 lightDirection = normalize(posCameraCoord - pointLights[0].position);
				vec3 totLight = clamp(dot(-lightDirection, n), 0.0, 1.0) * pointLights[0].color * lightIntensity;
				
				float noiseHeight = length(pos) - radius; // TODO: here the center of the planet is considered at the origin
				
				// deep sea, sea, sand, grass, grass2, mountain, mountain2, snow
				if (noiseHeight < 0.8) {
					gl_FragColor = texture2D(texture0, vUV); //vec4(0.118, 0.565, 1.0, 1.0);
				} else if (noiseHeight < 1.0) {
					gl_FragColor = texture2D(texture1, vUV); //vec4(0.0, 0.749, 1.0, 1.0);
				} else if (noiseHeight < 1.15) {
					gl_FragColor = texture2D(texture2, vUV); //vec4(0.957, 0.643, 0.376, 1.0);
				} else if (noiseHeight < 1.35) {
					gl_FragColor = texture2D(texture3, vUV); //vec4(0.196, 0.804, 0.196, 1.0);
				} else if (noiseHeight < 1.6) {
					gl_FragColor = texture2D(texture4, vUV); //vec4(0.133, 0.545, 0.133, 1.0);
				} else if (noiseHeight < 1.75) {
					gl_FragColor = texture2D(texture5, vUV); //vec4(0.627, 0.322, 0.176, 1.0);
				} else if (noiseHeight < 2.0) {
					gl_FragColor = texture2D(texture6, vUV); //vec4(0.545, 0.271, 0.075, 1.0);
				} else {
					gl_FragColor = texture2D(texture7, vUV); //vec4(1.0, 1.0, 1.0, 1.0);
				}
				
				gl_FragColor = gl_FragColor * vec4(totLight, 1.0);
			}
		</script>
		
		<!--<script type="x-shader/x-vertex" id="classicNoiseVertexShader">
			//
			// GLSL textureless classic 3D noise "cnoise",
			// with an RSL-style periodic variant "pnoise".
			// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
			// Version: 2011-10-11
			//
			// Many thanks to Ian McEwan of Ashima Arts for the
			// ideas for permutation and gradient selection.
			//
			// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
			// Distributed under the MIT license. See LICENSE file.
			// https://github.com/stegu/webgl-noise
			//
			
			vec3 mod289(vec3 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
		
			vec4 mod289(vec4 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			
			vec4 permute(vec4 x)
			{
				return mod289(((x*34.0)+1.0)*x);
			}
			
			vec4 taylorInvSqrt(vec4 r)
			{
				return 1.79284291400159 - 0.85373472095314 * r;
			}
			
			vec3 fade(vec3 t) {
				return t*t*t*(t*(t*6.0-15.0)+10.0);
			}
			
			// Classic Perlin noise
			float cnoise(vec3 P)
			{
				vec3 Pi0 = floor(P); // Integer part for indexing
				vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
				Pi0 = mod289(Pi0);
				Pi1 = mod289(Pi1);
				vec3 Pf0 = fract(P); // Fractional part for interpolation
				vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				vec4 iy = vec4(Pi0.yy, Pi1.yy);
				vec4 iz0 = Pi0.zzzz;
				vec4 iz1 = Pi1.zzzz;
				
				vec4 ixy = permute(permute(ix) + iy);
				vec4 ixy0 = permute(ixy + iz0);
				vec4 ixy1 = permute(ixy + iz1);
				
				vec4 gx0 = ixy0 * (1.0 / 7.0);
				vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
				gx0 = fract(gx0);
				vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				vec4 sz0 = step(gz0, vec4(0.0));
				gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				gy0 -= sz0 * (step(0.0, gy0) - 0.5);
				
				vec4 gx1 = ixy1 * (1.0 / 7.0);
				vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
				gx1 = fract(gx1);
				vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				vec4 sz1 = step(gz1, vec4(0.0));
				gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				gy1 -= sz1 * (step(0.0, gy1) - 0.5);
				
				vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
				
				vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
				g000 *= norm0.x;
				g010 *= norm0.y;
				g100 *= norm0.z;
				g110 *= norm0.w;
				vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
				g001 *= norm1.x;
				g011 *= norm1.y;
				g101 *= norm1.z;
				g111 *= norm1.w;
				
				float n000 = dot(g000, Pf0);
				float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				float n111 = dot(g111, Pf1);
				
				vec3 fade_xyz = fade(Pf0);
				vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
				return 2.2 * n_xyz;
			}
		
			// End of webgl-noise (pnoise function removed because unused).
		
			uniform float radius;
			
			uniform float scale;
			uniform float persistance;
			uniform float lacunarity;
			
			varying vec3 pos;
		
			void main() {
				
				const int octaves = 4;
				
				float amplitude = 1.0;
				float frequency = 1.0;
				float noiseHeight = 1.0;
				
				pos = position / length(position) * radius;
				
				for (int i = 0; i < octaves; ++i) {
					float sampleX = pos.x / scale * frequency;
					float sampleY = pos.y / scale * frequency;
					float sampleZ = pos.z / scale * frequency;
					
					float noiseValue = cnoise(vec3(sampleX, sampleY, sampleZ));
					
					noiseHeight += noiseValue * amplitude;
					
					amplitude *= persistance;
					frequency *= lacunarity;
				}
				
				// Spherify vertex and add noise height:
				pos = position / length(position) * (radius + exp(noiseHeight-1.0));
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
			}
		</script>
		<script type="x-shader/x-fragment" id="classicNoiseFragmentShader">
			
			// TODO: define colors etc.
			varying vec3 pos;
			
			uniform float radius;
			
			void main() {
				
				float noiseHeight = length(pos) - radius;
				
				if (noiseHeight < 0.8) {
					gl_FragColor = vec4(0.118, 0.565, 1.0, 1.0);
				} else if (noiseHeight < 1.0) {
					gl_FragColor = vec4(0.0, 0.749, 1.0, 1.0);
				} else if (noiseHeight < 1.15) {
					gl_FragColor = vec4(0.957, 0.643, 0.376, 1.0);
				} else if (noiseHeight < 1.35) {
					gl_FragColor = vec4(0.196, 0.804, 0.196, 1.0);
				} else if (noiseHeight < 1.6) {
					gl_FragColor = vec4(0.133, 0.545, 0.133, 1.0);
				} else if (noiseHeight < 1.75) {
					gl_FragColor = vec4(0.627, 0.322, 0.176, 1.0);
				} else if (noiseHeight < 2.0) {
					gl_FragColor = vec4(0.545, 0.271, 0.075, 1.0);
				} else {
					gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
				}
				
			}

		</script>-->
		
		<script src="src/Chunk.js"></script>
		<script src="src/NoiseHeightGenerator.js"></script>
		<script src="src/Planet.js"></script>
		<script src="src/Main.js"></script>
	</head>
	<body>
		
	</body>
</html>
